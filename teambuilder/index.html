<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Morimens Team Builder</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom scrollbar to match index.html */
        ::-webkit-scrollbar { width: 8px; height: 8px; }
        ::-webkit-scrollbar-track { background: #0f172a; } /* slate-950 */
        ::-webkit-scrollbar-thumb { background: #334155; border-radius: 4px; } /* slate-700 */
        ::-webkit-scrollbar-thumb:hover { background: #475569; } /* slate-600 */

        /* App specific styles */
        body { font-family: 'Inter', sans-serif; }
        
        .drag-source, .drag-clone {
            transition: all 0.2s ease-in-out;
            cursor: grab;
        }
        .drag-source:active, .drag-clone:active {
            cursor: grabbing;
        }
        .drag-source:hover, .drag-clone:hover {
            box-shadow: 0 4px 15px rgba(0, 0, 0, 0.4); /* Darker shadow */
            transform: translateY(-2px);
        }
        .drag-over {
            border: 2px dashed theme('colors.indigo.500') !important;
            background-color: theme('colors.slate.800') !important;
        }
        
        /* Classes to apply during resizing to prevent unwanted text selection and change cursor */
        .no-select-col {
            user-select: none;
            cursor: col-resize;
        }
        .no-select-row {
            user-select: none;
            cursor: row-resize;
        }
    </style>
</head>
<body class="bg-slate-950 text-slate-200 font-sans antialiased selection:bg-indigo-500 selection:text-white h-screen flex flex-col p-4 md:p-8">

    <div id="app" class="w-full mx-auto flex flex-col flex-grow overflow-hidden">
        
        <header class="mb-4 p-4 bg-slate-900 border border-slate-800 rounded-xl shadow-lg flex-shrink-0">
            <h1 class="text-3xl font-bold bg-gradient-to-r from-indigo-400 to-purple-400 bg-clip-text text-transparent">Morimens Team Builder</h1>
            <p class="text-slate-400 mt-1 text-sm">Right-click a unit to toggle between Owned/Unowned. Drag units from the roster to move them into the team rows below.</p>
        </header>

        <div class="flex flex-col lg:flex-row gap-8 lg:gap-0 flex-grow min-h-0" id="main-layout">

            <div id="roster-column" class="space-y-4 w-full transition-all duration-100 ease-out flex flex-col lg:flex-grow lg:min-h-0">
                
                <div id="search-block" class="bg-slate-900 p-6 rounded-xl border border-slate-800 shadow-lg flex-shrink-0">
                    <label for="awakener-search" class="block text-sm font-semibold uppercase tracking-wide text-slate-400 mb-2">Filter Roster</label>
                    <input type="text" id="awakener-search" placeholder="Search by name (e.g., 'Awakener-05') or faction..."
                            class="w-full bg-slate-800 text-slate-200 text-sm rounded border border-slate-700 pl-4 pr-4 py-3 focus:ring-2 focus:ring-indigo-500 focus:border-transparent outline-none placeholder:text-slate-600 shadow-inner">
                </div>

                <div id="owned-group" class="bg-slate-900 p-6 rounded-xl border border-slate-800 shadow-xl flex flex-col lg:flex-grow lg:min-h-0">
                    <div class="flex items-center gap-2 mb-4 border-b border-slate-700 pb-2 flex-shrink-0">
                        <div class="w-2 h-2 rounded-full bg-emerald-500"></div>
                        <h2 class="text-xl font-semibold text-slate-200">Owned Roster</h2>
                    </div>
                    <div id="owned-list" class="scroll-container overflow-y-auto p-2 flex flex-wrap gap-3 content-start flex-grow">
                        </div>
                </div>

                <div id="roster-splitter" 
                     class="h-2 w-full bg-slate-800 rounded-full cursor-row-resize hover:bg-indigo-500 border border-slate-700 transition-colors duration-200 flex-shrink-0 hidden lg:block"
                     title="Drag to resize Owned/Unowned panels">
                </div>

                <div id="unowned-group" class="bg-slate-900 p-6 rounded-xl border border-slate-800 shadow-xl flex flex-col lg:flex-grow lg:min-h-0">
                    <div class="flex items-center gap-2 mb-4 border-b border-slate-700 pb-2 flex-shrink-0">
                        <div class="w-2 h-2 rounded-full bg-rose-500"></div>
                        <h2 class="text-xl font-semibold text-slate-200">Unowned Roster</h2>
                    </div>
                    <div id="unowned-list" class="scroll-container overflow-y-auto p-2 flex flex-wrap gap-3 content-start flex-grow">
                        </div>
                </div>
            </div>

            <div id="drag-handle" 
                 class="hidden lg:block w-3 bg-slate-950 flex items-center justify-center cursor-col-resize flex-shrink-0 group"
                 title="Drag to resize panels">
                 <div class="w-1 h-12 bg-slate-700 rounded-full group-hover:bg-indigo-500 transition-colors"></div>
            </div>

            <div id="team-column" class="bg-slate-900 p-8 rounded-xl border border-slate-800 shadow-2xl flex flex-col lg:flex-grow lg:min-h-0">
                <div class="flex items-center gap-2 mb-6 border-b border-slate-700 pb-2 flex-shrink-0">
                    <h2 class="text-xl font-semibold text-slate-200">Team Composition</h2>
                </div>
                
                <div id="rows-container" class="space-y-0 overflow-y-auto pr-2 flex-grow">
                    </div>

                <button id="add-row-btn" class="mt-4 p-3 bg-indigo-600 hover:bg-indigo-500 text-white font-bold rounded-lg border border-indigo-500 transition duration-200 shadow-lg flex-shrink-0">
                    + Add Team Row (Max 10)
                </button>
            </div>
        </div>

    </div>

    <script>
        // --- DATA AND STATE MANAGEMENT ---
        
        let awakenersData = [];
        const TOTAL_UNITS = 52; 
        const MAX_ROWS = 10;
        const MAX_ROW_CAPACITY = 4; 
        const DATA_SOURCE_PATH = './awakeners.json'; // Adjusted path to be relative to root like index.html often is
        const FACTIONS = ["ULTRA", "CARO", "CHAOS", "AEQUOR"]; 

        let rowsState = [
            [], [], [], [], []
        ];
        
        let searchQuery = '';
        
        // --- RESIZING STATE ---
        let isResizing = false; 
        let isVerticalResizing = false; 
        let rosterColumn;
        let ownedGroup; 
        let unownedGroup; 
        let ownedHeightPercentage = 50; 
        const MIN_WIDTH_PERCENT = 20; 
        const MIN_PX_HEIGHT = 120; 

        function generateMockData() {
            console.log("Could not load external data. Using mock data fallback.");
            const mockData = [];
            for (let i = 0; i < TOTAL_UNITS; i++) {
                const name = `Awakener-${i.toString().padStart(2, '0')}`;
                const faction = FACTIONS[i % FACTIONS.length]; 
                mockData.push({ 
                    name: name, 
                    faction: faction, 
                    group: 'owned', 
                    displayName: name 
                });
            }
            awakenersData = mockData;
        }

        async function loadAwakenersData() {
            try {
                // Try ./awakeners.json first (common structure), then ../awakeners.json
                let response;
                try {
                     response = await fetch('./awakeners.json');
                     if(!response.ok) throw new Error("Not found");
                } catch (e) {
                     response = await fetch('../awakeners.json');
                }

                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const externalData = await response.json();
                
                if (!Array.isArray(externalData) || externalData.length === 0) {
                    throw new Error("External data is empty or invalid.");
                }

                const processedData = externalData.slice(0, TOTAL_UNITS).map((item, i) => ({
                    name: `Awakener-${i.toString().padStart(2, '0')}`, 
                    faction: FACTIONS.includes(item.faction) ? item.faction : "AEQUOR", 
                    displayName: item.name || `Awakener-${i.toString().padStart(2, '0')}`,
                    group: 'owned' 
                }));
                
                awakenersData = processedData;
                console.log(`Successfully loaded ${awakenersData.length} units.`);

            } catch (e) {
                console.error(`Error loading data:`, e);
                generateMockData();
            }
        }

        function getAwakenerByName(name) {
            return awakenersData.find(a => a.name === name);
        }

        function getAwakenerIndexByName(name) {
            return name.split('-')[1];
        }
        
        function getAwakenerNameByIndex(indexString) {
            return `Awakener-${indexString}`;
        }

        function serializeState() {
            const rowsString = rowsState.map(row => 
                row.map(name => getAwakenerIndexByName(name)).join(',')
            ).join(';');

            const unownedIndices = awakenersData
                .filter(a => a.group === 'unowned')
                .map(a => getAwakenerIndexByName(a.name));
            const unownedString = unownedIndices.join(',');

            const rawState = `${rowsString}&${unownedString}`;
            return rawState;
        }

        function deserializeState(rawState) {
            if (!rawState) return;
            try {
                const parts = rawState.split('&');
                const rowsPart = parts[0]; 
                const unownedPart = parts[1] || ''; 

                const newRowsState = rowsPart.split(';').map(rowString => {
                    const indices = rowString.split(',').filter(index => index.length > 0);
                    return indices.map(index => getAwakenerNameByIndex(index)).filter(name => getAwakenerByName(name));
                }).filter(row => row.length > 0 || newRowsState.length === 0); 

                rowsState = newRowsState.length > 0 ? newRowsState : [[]];
                
                awakenersData.forEach(a => a.group = 'owned'); 

                if (unownedPart.length > 0) {
                    const unownedIndices = unownedPart.split(',').filter(index => index.length > 0);
                    unownedIndices.forEach(index => {
                        const name = getAwakenerNameByIndex(index);
                        const awakener = getAwakenerByName(name);
                        if (awakener) {
                            awakener.group = 'unowned';
                        }
                    });
                }
            } catch (e) {
                console.error("Failed to load state from URL:", e);
            }
        }

        function updateUrlState() {
            const rawState = serializeState();
            const encodedState = encodeURIComponent(rawState);
            const newUrl = `${window.location.pathname}?state=${encodedState}`;
            history.replaceState(null, '', newUrl); 
        }

        function loadStateFromUrl() {
            const params = new URLSearchParams(window.location.search);
            const rawState = params.get('state');
            if (rawState) {
                const decodedState = decodeURIComponent(rawState);
                deserializeState(decodedState);
                console.log("State loaded from URL.");
            }
        }

        // --- UTILITY FUNCTIONS ---

        function isAwakenerInTeam(name) {
            return rowsState.some(row => row.includes(name));
        }

        /**
         * Determines Tailwind classes based on faction.
         * UPDATED: Uses dark mode colors to match index.html style
         */
        function getFactionClasses(faction) {
            switch (faction) {
                case "ULTRA": return 'border-purple-700 text-purple-200 bg-purple-900/20';
                case "CARO": return 'border-red-700 text-red-200 bg-red-900/20';
                case "CHAOS": return 'border-yellow-600 text-yellow-200 bg-yellow-900/20';
                case "AEQUOR":
                default: return 'border-blue-700 text-blue-200 bg-blue-900/20';
            }
        }

        /**
         * Creates the HTML element for an Awakener card.
         * UPDATED: Styling matches the dark card aesthetic.
         */
        function createAwakenerCard(awakener, isClone = false, rowId = null) {
            const card = document.createElement('div');
            const factionClasses = getFactionClasses(awakener.faction); 

            // Base classes - added border and dark background logic
            let classes = `flex flex-col items-center w-28 h-32 p-1 rounded-lg border shadow-lg hover:shadow-xl transition duration-200`;
            
            const awakenerName = awakener.name; 
            const displayName = awakener.displayName || awakenerName; 

            if (!isClone) {
                classes += ` drag-source cursor-pointer ${factionClasses}`;
                card.draggable = true;
                card.ondragstart = (e) => handleDragStart(e, awakenerName, null); 
                card.oncontextmenu = (e) => {
                    e.preventDefault(); 
                    toggleAwakenerGroup(awakenerName); 
                };
            } else {
                classes += ` drag-clone cursor-pointer ${factionClasses}`;
                card.draggable = true;
                card.ondragstart = (e) => handleDragStart(e, awakenerName, rowId); 
            }
            
            if (awakener.group === 'unowned') {
                classes += ' filter grayscale opacity-40 hover:opacity-80'; 
            }

            card.className = classes;
            card.dataset.name = awakenerName; 

            // Handle images relative to index.html location
            const imageUrl = `../images/awakeners/${displayName}.png`;
            const fallbackImageUrl = `https://placehold.co/100x100/1e293b/94a3b8?text=${displayName.replace(/[-\s]/g, '%20')}`;

            card.innerHTML = `
                <div class="text-[10px] font-bold uppercase tracking-wider truncate w-full text-center mb-1 opacity-90">${displayName}</div>
                <img 
                    src="${imageUrl}" 
                    alt="${displayName} image" 
                    class="w-20 h-20 object-cover rounded-md border border-slate-600 shadow-sm bg-slate-800"
                    onerror="this.onerror=null; this.src='${fallbackImageUrl}';"
                />
            `;
            return card;
        }

        function toggleAwakenerGroup(name) {
            const awakener = getAwakenerByName(name);
            if (awakener) {
                if (isAwakenerInTeam(name)) {
                    console.warn(`Cannot toggle status for ${name}. It is currently in a team row.`);
                    return;
                }
                
                awakener.group = awakener.group === 'owned' ? 'unowned' : 'owned';
                renderAwakeners();
                updateUrlState();
            }
        }

        function renderAwakeners() {
            const ownedList = document.getElementById('owned-list');
            const unownedList = document.getElementById('unowned-list');

            ownedList.innerHTML = '';
            unownedList.innerHTML = '';

            const query = searchQuery.toLowerCase().trim();

            const filteredAwakeners = awakenersData.filter(awakener => {
                if (isAwakenerInTeam(awakener.name)) {
                    return false;
                }

                if (query === '') {
                    return true;
                }

                return awakener.displayName.toLowerCase().includes(query) ||
                        awakener.name.toLowerCase().includes(query) ||
                        awakener.faction.toLowerCase().includes(query);
            });

            filteredAwakeners.forEach(awakener => {
                const card = createAwakenerCard(awakener);
                if (awakener.group === 'owned') {
                    ownedList.appendChild(card);
                } else {
                    unownedList.appendChild(card);
                }
            });
        }
        
        function handleSearchInput(e) {
            searchQuery = e.target.value;
            renderAwakeners(); 
        }

        /**
         * Renders the cards placed in the team composition rows.
         * UPDATED: Uses dark mode colors for row backgrounds.
         */
        function renderRows() {
            const rowsContainer = document.getElementById('rows-container');
            rowsContainer.innerHTML = ''; 

            rowsState.forEach((rowNames, index) => { 
                const rowElement = document.createElement('div');
                rowElement.id = `row-${index}`;
                
                // UPDATED: bg-slate-800 border-slate-700 to match panels
                rowElement.className = 'team-row p-2 bg-slate-800/50 border border-slate-700 rounded-lg shadow-inner flex flex-nowrap gap-2 overflow-x-auto transition duration-300 mb-2 items-center';
                
                const labelContainer = document.createElement('div');
                labelContainer.className = 'flex flex-col items-center justify-center w-full sm:w-auto flex-shrink-0 min-w-[70px] px-2 border-r border-slate-700 mr-2';
                
                const label = document.createElement('p');
                // UPDATED: Text color
                label.className = 'row-label text-indigo-400 font-bold text-sm uppercase tracking-wide';
                label.textContent = `Row ${index + 1}`;
                labelContainer.appendChild(label);

                const deleteBtn = document.createElement('button');
                // UPDATED: Text color and hover state
                deleteBtn.className = 'text-slate-600 hover:text-red-400 font-bold p-1 leading-none text-xl mt-1 transition-colors';
                deleteBtn.innerHTML = '&times;'; 
                deleteBtn.title = `Delete Row ${index + 1}`;

                if (rowsState.length > 1) {
                    deleteBtn.onclick = (e) => {
                        e.stopPropagation(); 
                        deleteRow(index);
                    };
                } else {
                    deleteBtn.disabled = true;
                    deleteBtn.classList.add('opacity-0', 'cursor-not-allowed');
                }
                
                labelContainer.appendChild(deleteBtn);
                rowElement.appendChild(labelContainer); 
                
                rowElement.addEventListener('dragover', handleDragOver);
                rowElement.addEventListener('dragenter', handleDragEnter);
                rowElement.addEventListener('dragleave', handleDragLeave);
                rowElement.addEventListener('drop', handleDrop);

                rowNames.forEach(name => {
                    const awakener = getAwakenerByName(name);
                    if (awakener) {
                        const cardClone = createAwakenerCard(awakener, true, index); 
                        rowElement.appendChild(cardClone);
                    }
                });
                
                rowsContainer.appendChild(rowElement);
            });
            
            updateAddRowButtonStatus();
        }

        function addRow() {
            if (rowsState.length < MAX_ROWS) {
                rowsState.push([]);
                renderRows(); 
                updateUrlState(); 
                console.log(`Added new row. Total rows: ${rowsState.length}`);
            } else {
                console.warn(`Cannot add more rows. Maximum limit of ${MAX_ROWS} reached.`);
            }
        }
        
        function deleteRow(rowIndex) {
            if (rowsState.length <= 1) {
                console.warn("Cannot delete the last remaining row.");
                return;
            }

            const unitsInDeletedRow = rowsState[rowIndex];

            rowsState.splice(rowIndex, 1);
            
            renderRows();
            renderAwakeners();
            updateUrlState(); 

            console.log(`Deleted Row ${rowIndex + 1}.`);
        }

        function updateAddRowButtonStatus() {
            const btn = document.getElementById('add-row-btn');
            if (btn) {
                if (rowsState.length >= MAX_ROWS) {
                    btn.disabled = true;
                    btn.textContent = `Max Rows (${MAX_ROWS}) Reached`;
                    btn.className = "mt-4 p-3 bg-slate-800 text-slate-500 font-bold rounded-lg border border-slate-700 cursor-not-allowed flex-shrink-0";
                } else {
                    btn.disabled = false;
                    btn.textContent = `+ Add Team Row (Max ${MAX_ROWS})`;
                    btn.className = "mt-4 p-3 bg-indigo-600 hover:bg-indigo-500 text-white font-bold rounded-lg border border-indigo-500 transition duration-200 shadow-lg flex-shrink-0";
                }
            }
        }

        // --- EVENT HANDLERS (Drag & Drop) ---

        function handleDragStart(e, awakenerName, sourceRowId) {
            const dragData = {
                name: awakenerName, 
                sourceRowId: sourceRowId 
            };
            e.dataTransfer.setData('application/json', JSON.stringify(dragData));
            e.dataTransfer.effectAllowed = 'move';
        }

        function handleDragEnter(e) {
            e.target.closest('.team-row, #owned-list, #unowned-list')?.classList.add('drag-over');
        }

        function handleDragLeave(e) {
            e.target.closest('.team-row, #owned-list, #unowned-list')?.classList.remove('drag-over');
        }
        
        function handleDragOver(e) {
            e.preventDefault(); 
            e.dataTransfer.dropEffect = 'move';
        }

        function handleDrop(e) {
            e.preventDefault();
            const rowElement = e.target.closest('.team-row');
            if (!rowElement) return;

            rowElement.classList.remove('drag-over');

            try {
                const dragData = JSON.parse(e.dataTransfer.getData('application/json'));
                const awakenerName = dragData.name; 
                const sourceRowId = dragData.sourceRowId; 
                const targetRowId = parseInt(rowElement.id.split('-')[1]);
                
                const isAlreadyInTarget = rowsState[targetRowId].includes(awakenerName);

                if (!isAlreadyInTarget) {
                    if (rowsState[targetRowId].length >= MAX_ROW_CAPACITY) { 
                        console.log(`Row ${targetRowId + 1} is full.`);
                        return; 
                    }
                }
                
                if (sourceRowId !== null) {
                    const rowId = parseInt(sourceRowId);
                    rowsState[rowId] = rowsState[rowId].filter(name => name !== awakenerName);
                }

                if (!isAlreadyInTarget) {
                    rowsState[targetRowId].push(awakenerName); 
                } 

                renderRows();
                renderAwakeners(); 
                updateUrlState();

            } catch (e) {
                console.error("Failed to process drop:", e);
            }
        }

        function handleRosterDrop(e) {
            e.preventDefault();
            const listElement = e.target.closest('#owned-list, #unowned-list');
            if (!listElement) return;

            listElement.classList.remove('drag-over');

            try {
                const dragData = JSON.parse(e.dataTransfer.getData('application/json'));
                const awakenerName = dragData.name;
                const sourceRowId = dragData.sourceRowId;

                if (sourceRowId !== null) {
                    const rowId = parseInt(sourceRowId);
                    rowsState[rowId] = rowsState[rowId].filter(name => name !== awakenerName);
                }

                const awakener = getAwakenerByName(awakenerName);
                if (awakener) {
                    const targetGroup = listElement.id === 'owned-list' ? 'owned' : 'unowned';
                    if (sourceRowId === null && awakener.group === targetGroup) {
                        return; 
                    }
                    awakener.group = targetGroup;

                    renderRows();
                    renderAwakeners();
                    updateUrlState();
                }

            } catch (e) {
                console.error("Failed to process roster drop:", e);
            }
        }

        // --- RESIZE LOGIC ---

        function setupResizers() {
            rosterColumn = document.getElementById('roster-column');
            ownedGroup = document.getElementById('owned-group');
            unownedGroup = document.getElementById('unowned-group');
            const dragHandle = document.getElementById('drag-handle');
            const rosterSplitter = document.getElementById('roster-splitter');
            const mainLayout = document.getElementById('main-layout');

            // --- HORIZONTAL RESIZE (Roster vs Team) ---
            dragHandle.addEventListener('mousedown', (e) => {
                isResizing = true;
                mainLayout.classList.add('no-select-col');
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const rect = mainLayout.getBoundingClientRect();
                let newWidth = e.clientX - rect.left;
                
                const minPxWidth = rect.width * (MIN_WIDTH_PERCENT / 100);
                const maxPxWidth = rect.width * (1 - MIN_WIDTH_PERCENT / 100);

                if (newWidth < minPxWidth) newWidth = minPxWidth;
                if (newWidth > maxPxWidth) newWidth = maxPxWidth;

                rosterColumn.style.flexBasis = `${newWidth}px`;
                rosterColumn.style.flexGrow = '0'; 
                rosterColumn.style.flexShrink = '0';
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    mainLayout.classList.remove('no-select-col');
                }
                if (isVerticalResizing) {
                    isVerticalResizing = false;
                    mainLayout.classList.remove('no-select-row');
                }
            });

            // --- VERTICAL RESIZE (Owned vs Unowned) ---
            rosterSplitter.addEventListener('mousedown', (e) => {
                isVerticalResizing = true;
                mainLayout.classList.add('no-select-row');
                e.preventDefault();
            });

            document.addEventListener('mousemove', (e) => {
                if (!isVerticalResizing) return;

                const rect = rosterColumn.getBoundingClientRect();
                const ownedRect = ownedGroup.getBoundingClientRect();

                let newHeight = e.clientY - ownedRect.top;

                const maxNewHeight = rect.height - MIN_PX_HEIGHT - rosterSplitter.offsetHeight - 20; 
                
                if (newHeight < MIN_PX_HEIGHT) newHeight = MIN_PX_HEIGHT;
                if (newHeight > maxNewHeight) newHeight = maxNewHeight;

                ownedHeightPercentage = (newHeight / rect.height) * 100;

                ownedGroup.style.flexBasis = `${newHeight}px`;
                ownedGroup.style.flexGrow = '0';
                unownedGroup.style.flexGrow = '1';
                unownedGroup.style.minHeight = `${MIN_PX_HEIGHT}px`; 
            });

            const applyInitialSplit = () => {
                const rect = rosterColumn.getBoundingClientRect();
                if (rect.height > 0) {
                    const initialHeight = (rect.height * ownedHeightPercentage / 100);
                    ownedGroup.style.flexBasis = `${initialHeight}px`;
                    ownedGroup.style.flexGrow = '0';
                    unownedGroup.style.flexGrow = '1';
                }
            };
            setTimeout(applyInitialSplit, 50); 
            window.addEventListener('resize', applyInitialSplit);
        }

        function setupEventListeners() {
            document.getElementById('awakener-search').addEventListener('input', handleSearchInput);
            document.getElementById('add-row-btn').addEventListener('click', addRow);
            
            const ownedList = document.getElementById('owned-list');
            const unownedList = document.getElementById('unowned-list');
            
            [ownedList, unownedList].forEach(list => {
                list.addEventListener('dragover', handleDragOver);
                list.addEventListener('dragenter', handleDragEnter);
                list.addEventListener('dragleave', handleDragLeave);
                list.addEventListener('drop', handleRosterDrop);
            });
        }

        async function init() {
            await loadAwakenersData();
            loadStateFromUrl();
            renderRows();
            renderAwakeners();
            setupEventListeners();
            setupResizers();
            updateUrlState(); 
            console.log("App initialized.");
        }

        window.onload = init;
    </script>
</body>
</html>